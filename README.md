나의 로직에서 발생할 수 있는 동시성은 
한 사람이 포인트 충전( 한 사람이 다양한 브라우저에서나 다양한 기종에서 접근하는 경우 ),
좌석 예매하기 ( 많은 사람이 한 좌석에 대해서 접근하는 경우 )

동시성을 해결하기 위한 방법에 Lock이라는 기술을 사용하는 데, 
어플리케이션단에서 구현할 수 있는 락과
DB단에서 구현하는 락이 존재한다.

---

**Lock 정리**

1. Application Lock
- @Synchronized @ReentrantLock
	- 개발방식: 
	- 단점 : 분산 시스템에서 데이터 일관성을 보장하기 어렵고, 서버가 다운되면 락이 해제되어 버리는 문제가 발생한다.

2. DB Lock
- 낙관적 락 : 충돌이 적다고 가정하는 방식
	- 개발방식: Version으로 관리를 함
	ex) 사용자1(웹) - 포인트 충전 userPoint(1L, 20000); - version 1
	     사용자1(앱) - 포인트 충전 userPoint(1L, 40000); - version 2
  ```
  @Version
  private Long version;
  ```
	- 속도: 충돌이 적다고 가정하기 때문에, 락이 촘촘하게 걸리지 않는다. 그렇기 때문에 속도에서 빠른 성능을 보여준다.
	- 구조의 복잡성: 개발 자체의 복잡성은 어노테이션 사용이라 복잡하지 않지만, 충돌이 발생 시에는 비관적 락보다는 복잡하다. 충돌이 발생 시, 롤백을 수동으로 처리해야한다.
- 비관적 락 : 충돌이 많다고 가정하는 방식
	- 속도: 낙관적 락에 비해 락이 촘촘하게 걸리기 때문에, 속도면에서 느리다.
	- 구조의 복잡성: 충돌이 발생해도 롤백을 수동처리 할 필요가 없다.
  ```
  @Lock(LockModeType.PESSIMISTIC_WRITE)
  ```
- 분산락 : 서버가 여러 대인 상황에서 동일한 데이터에 대한 동기화를 보장
	- 속도: 네트워크 통신 및 분산 환경에서의 동기화로 속도가 가장 느릴 수 있다.
	- 개발방식: Redis, DataBase, Zookeeper 등으로 분산락을 구현할 수 있다.
	- 구조의 복잡성: Spring Boot의 독단적으로 해결할 수 없고, 외부의 기술들을 사용해야하기 때문에, 낙관적 락/비관적 락에 비하면 복잡하다.

---

### 장단점을 살펴본 결과 
한 사람이 포인트 충전 : 충돌이 적은 특성을 생각 했을 때, 낙관적 락을 사용하면 좋을 것 같아서 채택할 예정
좌석 예매하기: 많은 사람들이 하나의 좌석을 접근하는 것으로  충돌이 많음, 비관적락과 분산락을 생각해봐서 둘 중 하나를 채택하려고 했으며 러닝 커브를 생각하면 비관적 락을 구현하는 것이 좋아 보이나
나중에 예매 기능은 따로 분산적인 기능으로 빼낼 수 있다는 것을 생각했을 때, 분산락을 구현하는 것이 좋다고 생각해서 채택할 예정
